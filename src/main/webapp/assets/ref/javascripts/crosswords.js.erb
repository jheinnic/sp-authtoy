// TODO LIST:
// P1:
// -- Rudimentary Your Letter Fields
// -- Reading hidden form fields in during initialize for edit
// -- AJAX call to load different card state without page reload
// -- AJAX call to wait on payout stats update on save
// -- AJAX call to save and update payout stats on edit
// P2:
// -- Your Letters UI
// P3:
// -- Bootstrap dialogs
// -- Cursor blinking

  String.prototype.format = function(values) {
    var regex = /\{([\w-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g;
  
    var getValue = function(key) {
      if(values == null || typeof values === 'undefined') return null;
  
      var value = values[key];
      var type = typeof value;
  
      return type === 'string' || type === 'number' ? value : null;
    };
  
    return this.replace(regex, function(match) { 
      //match will look like {sample-match}
      //key will be 'sample-match';
      var key = match.substr(1, match.length - 2);
  
      var value = getValue(key);
  
      return value != null ? value : match;
    });
  };

  var $currentKeyHandler;
  var $currentChangeHandler;

  var $editorCell = null;
  var $openRange = null;
  var $wordRange = null;

  var $hasAltDir = true;
  var $wordCount = 0;
  var $tripleCellCount = 0;

  // GRID NODE:
  // Every grid is an 11x11 2-dimensional array of node objects.  There are
  // two node objects for each physical location.
  // 
  // HORIZONTAL GRID NODE:
  // The horizontal node has its row and col properties set using the same
  // coordinates as in the physical display grid.  Its navigation pointers are
  // threaded such that left, right, up, and down behave exactly as one would
  // expect given the display grid.
  //
  // VERTICAL GRID NODE:
  // The vertical node has its row and col properties set by inverting the
  // coordinates used in the physical display grid such that (row, col) in the
  // node maps to (col, row) in the physical grid.  Its navigation pointers are
  // threaded such that left, right, up, and down behave as though the display
  // grid had been rotate 90 degrees clockwise.
  //
  // GRIDS:
  // The difference between "logical" and "physical" grids is whether or not
  // their x,y coordinates are sensitive to the "edit orientation toggle".
  // In either case, both grids are composed either of all horizontal grid 
  // nodes or all vertical grid nodes.
  // 
  // For any given (x,y) coordinate pair, the following rules hold true
  // before and after a change of editor orientation mode:
  // 1) PhysicalGrid[x,y] before the change will return an object that 
  //    describes the same crossword cell as PhysicalGrid[x,y] afterwards.
  // 2) LogicalGrid[x,y] before the change will return an object that 
  //    describes the same crossword cell as LogicalGrid[y,x] afterwards.
  // 3) The pair of nodes will be threaded for different logical perspectives
  //    such that:
  // nodeOne.col      =  nodeTwo.row     | nodeOne.row      =  nodeTwo.col
  // nodeOne.toLeft   =  nodeTwo.toAbove | nodeOne.toRight  =  nodeTwo.toBelow
  // nodeOne.toAbove  =  nodeTwo.toLeft  | nodeOne.toBelow  =  nodeTwo.toRight
  //
  // LOGICAL GRID:
  // (X,Y) in horizontal mode yields an object threaded for horizontal access
  // that describes the same cell as the object threaded for vertical access
  // found at (Y,X) in vertical mode.
  //
  // PHYSICAL GRID:
  // (X,Y) in horizontal mode yields an object threaded for horizontal access
  // that describes the same cell as the object threaded for vertical access
  // found at (X,Y) in vertical mode.
  //
  // Note that the constant addressing for non-toggling cell coordinates does
  // NOT prevent the object retrieved in vertical mode from behaving differently
  // from that retrieved in horizontal mode.  Just because the means of lookup
  // is orientation-agnostic doesn't constrain the retrieved objects to also
  // be orientation-agnostic.
  //
  // Note that the logical and physical grids are identical in horizontal mode,
  // but not vertical mode.
  var $horizontalGrid = [];
  var $verticalPhysical = [];
  var $verticalLogical = [];

  // The active pair of physical and logical grids.
  var $physicalGrid = $horizontalGrid;
  var $logicalGrid = $horizontalGrid;

  // A JQuery object wrapping the entire document's root node.
  var $docWrapper;

  // A JQuery objects wrapping:
  // 1) The <table> for the crossword grid.
  // 2) The <table> for the bonus word grid.
  // 3) The <table> for the bonus value spot.
  // 4) The <table> for the "your letters" grid.
  // 5) The <table> for the word badge summary.
  // 6) The <table> for the prize distribution summary.
  var $crosswordTable;
  var $bonusWordTable;
  var $bonusValueTable;
  var $yourLettersTable;
  var $wordBadgeTable;
  var $prizeDistTable;
  
  var $bonusValLastClicked = -1;
  var $bonusValLastSaved   = -1;

  var $blankImage = '<%= path_to_image 'val/blank.png' %>';
  var $cursorImage = '<%= path_to_image 'val/qm.png' %>';
  var $valueImages = $( {
    A: '<%= path_to_image 'val/A.png' %>', B: '<%= path_to_image 'val/B.png' %>',
    C: '<%= path_to_image 'val/C.png' %>', D: '<%= path_to_image 'val/D.png' %>',
    E: '<%= path_to_image 'val/E.png' %>', F: '<%= path_to_image 'val/F.png' %>',
    G: '<%= path_to_image 'val/G.png' %>', H: '<%= path_to_image 'val/H.png' %>',
    I: '<%= path_to_image 'val/I.png' %>', J: '<%= path_to_image 'val/J.png' %>',
    K: '<%= path_to_image 'val/K.png' %>', L: '<%= path_to_image 'val/L.png' %>',
    M: '<%= path_to_image 'val/M.png' %>', N: '<%= path_to_image 'val/N.png' %>',
    O: '<%= path_to_image 'val/O.png' %>', P: '<%= path_to_image 'val/P.png' %>',
    Q: '<%= path_to_image 'val/Q.png' %>', R: '<%= path_to_image 'val/R.png' %>',
    S: '<%= path_to_image 'val/S.png' %>', T: '<%= path_to_image 'val/T.png' %>',
    U: '<%= path_to_image 'val/U.png' %>', V: '<%= path_to_image 'val/V.png' %>',
    W: '<%= path_to_image 'val/W.png' %>', X: '<%= path_to_image 'val/X.png' %>',
    Y: '<%= path_to_image 'val/Y.png' %>', Z: '<%= path_to_image 'val/Z.png' %>'
  } );

  var $fillImages = {
    pink: '<%= path_to_image 'fill/pink2.png' %>',
    selected: '<%= path_to_image 'fill/selected1.png' %>',
    scratched: '<%= path_to_image 'fill/scratched.png' %>',
    silver: '<%= path_to_image 'fill/SilverCover.png' %>'
  };

  var $formSelectors = {
    bonusWord: 'input#crossword_bonus_word',
    bonusValue: 'input#crossword_bonus_value',
    revealed: 'input#crossword_revealed',
    xCoord: 'input#crossword_word_items_attributes_{idx}_x_coordinate',
    yCoord: 'input#crossword_word_items_attributes_{idx}_y_coordinate',
    isHoriz: 'input#crossword_word_items_attributes_{idx}_is_horizontal',
    textValue: 'input#crossword_word_items_attributes_{idx}_text_value',
    tripleIndex: 'input#crossword_word_items_attributes_{idx}_triple_letter_index'
  };

  var $bonusValImages = [ 
    '<tr><td><img class="xw-value" src="<%= path_to_image 'val/4.png' %>"></td></tr>',
    '<tr><td><img class="xw-value" src="<%= path_to_image 'val/5.png' %>"></td></tr>',
    '<tr><td><img class="xw-value" src="<%= path_to_image 'val/10.png' %>"></td></tr>',
    '<tr><td><img class="xw-value" src="<%= path_to_image 'val/30.png' %>"></td></tr>'
  ];
    
  function initialize() {
    $crosswordTable    = $('table#lettergrid');
    $bonusWordTable    = $('table#bonusword');
    $bonusValueTable   = $('table#bonusvalue');
    $yourLettersTable  = $('table#yourletters');
    $wordBadgeTable    = $("table#wordsummary");
    $prizeDistTable    = $("table#prizeinfo");

    var selectRowTmpl = 'div.xw-cell[data-rowid="{row}"]';
    var selectColTmpl = 'div.xw-cell.xw-cell[data-colid="{col}"]';

    // Iterate through the cells in document order, adding image data to
    // each cell and building a horizontal doubly linked lists connecting
    // immediate neighbors for horizontal navigability.
    for (var row=0; row<11; row++) {
      var lastHCell = null;
      var lastVCell = null;
      $horizontalGrid[row]   = [];
      $verticalPhysical[row] = [];

      var thisRow   = $(selectRowTmpl.format({row: row}), $crosswordTable);

      thisRow.each(
        function(col, nextElement) { 
          var thisHCell = {
            row: row,
            col: col,
            selfNode: $(nextElement),
            sameRow: thisRow,
            open: {
              parallel: { head: 0, tail: 10, length: 11 },
              crossing: { head: 0, tail: 10, length: 11 }
            },
            toLeft: lastHCell,
            toRight: null,
            toAbove: null,
            toBelow: null
          };
          var thisVCell = {
            row: col,
            col: row,
            selfNode: thisHCell.selfNode,
            sameRow: null,
            open: {
              parallel: thisHCell.open.crossing,
              crossing: thisHCell.open.parallel
            },
            toLeft: null,
            toRight: null,
            toAbove: thisHCell,
            toBelow: null
          };

          if(col != 0) {
            lastHCell.toRight = thisHCell;
            lastVCell.toBelow = thisVCell;
          }
  
          // Cell coordinates are inverted within the objects to support
          // dimension toggling, but the lookup arrays are not inverted
          // because they are accessed using the physical coordinates on
          // each cell's <dim> tag, which do not change when the edit
          // dimension is toggled.
          lastHCell = thisHCell;
          lastVCell = thisVCell;
          $horizontalGrid[row][col]   = thisHCell;
          $verticalPhysical[row][col] = thisVCell;
        }
      );
    }

    // Populate a second double linked list between cells in the same column
    // for vertical navigability, and add functions for use by the click and
    // keyboard event handlers that derive subsets of connected cells for word
    // boundary highlighting and cursor position management.
    for (var col=0; col<11; col++) {
      var lastHCell = null;
      var lastVCell = null;
      $verticalLogical[col]   = [];

      var thisCol = $(selectColTmpl.format({col: col}), $crosswordTable);

      thisCol.each(
        function(row, nextElement) { 
          var thisHCell = $horizontalGrid[row][col];
          var thisVCell = $verticalPhysical[row][col];

         thisVCell.sameRow = thisCol;
  
          thisHCell.toAbove = lastHCell;
          thisVCell.toLeft  = lastVCell;
  
          if(row != 0) {
            lastHCell.toBelow = thisHCell;
            lastVCell.toRight = thisVCell;
          }
  
          lastHCell = thisHCell;
          lastVCell = thisVCell;
          $verticalLogical[col][row] = thisVCell;
        }
      );
    } // Latter of two intialization "for" loops.


    if(!("WebSocket" in window)) {
      alert("Sorry, the build of your browser does not support WebSockets.  Ticket analysis refresh is adversely affected.")
      ws = { send: function(msg) {} };
    } else {
      //ws = new WebSocket("ws://www.jchein.info:8080/crossword/recalculator");
      //ws.onmessage = function(evt) {updateView(evt.data);}
    }

    // Get a document jQuery wrapper to use when setting key-down handlers.
    $docWrapper = $(document);

    // Set click handlers for each clickable entity.
    $crosswordTable.on('contextmenu', 'div.xw-cell', onCrosswordContext);
    $crosswordTable.on('click', 'div.xw-cell', onCrosswordClick);
    $bonusWordTable.on('click', 'div.xw-cell', onBonusWordClick);
    $bonusValueTable.on('click', onBonusValueClick);
    $yourLettersTable.on('click', onYourLettersClick);

    $("div#bonusradio").on('click', 'button', onBonusValueSelectClick);
    $("a#bonusmodalsave").on('click', onBonusValueSaveClick);
    $("a#bonusmodalcancel").on('click', onBonusValueCancelClick);
    $("div#bonusmodal div.modal-header button").on(
      'click', onBonusValueCancelClick);
  }

  //
  // Asynchronous model render mode
  //

  function updateView(modelText) {
    modelState = eval("(" + modelText + ")");
    console.log(modelState);

    for( ii=0; ii<5; ii++ ) {
      var c = modelState.bonus_word[ii]
      var wrap = $('div.xw-cell', $bonusWordTable).eq(ii);
      $('img.xw-value', wrap).attr('src', $valueImages.attr(c));
      wrap.data('content', c);
    }

    $($formSelectors.bonusWord).val(modelState.bonus_word);

    // TODO: Ensure horizontal mode
    // TODO: Apply formSelectors and badges to word text_values and propogate
    //       other word items.  Initialize tripler state (and later reveal state)
    for( ii=0; ii<modelState.word_items.length; ii++ ) {
      var w = modelState.word_items[ii]
      console.log(w)
      var wrap = $physicalGrid[w.x_coordinate][w.y_coordinate]
      if (w.is_horizontal && ($dirModeStrategy == $horizontalStrategy)) {
        for( jj=0; jj<w.text_value.length; jj++ ) {
          var c = w.text_value[jj]
          $('img.xw-value', wrap.selfNode).attr('src', $valueImages.attr(c));
          wrap.selfNode.data('content', c);
          wrap = wrap.toRight;
        }
      } else {
        for( jj=0; jj<w.text_value.length; jj++ ) {
          var c = w.text_value[jj]
          $('img.xw-value', wrap.selfNode).attr('src', $valueImages.attr(c));
          wrap.selfNode.data('content', c);
          wrap = wrap.toBelow;
        }
      }
    }

    for( ii=0; ii<modelState.revealed.length; ii++ ) {
      var c = modelState.revealed[ii]
      var wrap = $('div.xw-cell', $yourLettersTable).eq(ii);
      $('img.xw-value', wrap).attr('src', $valueImages.attr(c));
      wrap.data('content', c);
    }
    $($formSelectors.revealed).val(modelState.revealed);

    // TODO: Any propogation requirements here?  PUT/POST consideration.  
    //       Preference is to use PUT and omit these, if that can work.
    // $($formSelectors.last_calc_revealed).val(modelState.last_calc_revealed);
    // $($formSelectors.actual_payout).val(modelState.actual_payout);
  }

  //
  // Javascript Event Handlers
  //

  function onCrosswordClick(event) {
    selectChangeHandler(onChangeFromCrossword);

    var wrap = $(this); 
    goToCell(wrap.data('rowid'), wrap.data('colid'));
    
    selectKeyboardHandler(onCrosswordKeyInput);
  }
  
  function onBonusWordClick(event) {
    selectChangeHandler(onChangeFromBonusWord);

    var wrap = $(this); 
    var cellIdx = $("div.xw-cell", $bonusWordTable).index(wrap);
    $bonusWordTable.data('active', cellIdx);
    $bonusWordTable.removeClass('xw-inactive').addClass('xw-active');
    $("img.xw-value", wrap).attr('src', $cursorImage);
    
    selectKeyboardHandler(onBonusWordKeyInput);
  }
  
  function onYourLettersClick(event) {
    selectChangeHandler(onChangeFromYourLetters);

    var cellIdx = $yourLettersTable.data('active');
    alert(cellIdx)
    var wrap = $("div.xw-cell", $yourLettersTable).eq(cellIdx);
    alert(wrap)
    $("img.xw-value", wrap).attr('src', $cursorImage);
    alert($("img.xw-value", wrap))

    selectKeyboardHandler(onYourLettersKeyInput);
  }

  function onBonusValueClick(event) {
    // TODO: Set bonus prize modal
    $("div#bonusmodal").modal('show');
  }

  function onBonusValueSelectClick(event) {
    var wrap = $(event.target);
    $bonusValLastClicked = $("div#bonusradio button").index(wrap);
  }

  function onBonusValueCancelClick(event) {
    $("div#bonusmodal").modal('hide');

    if ($bonusValLastSaved > -1) {
      $("div#bonusradio button").eq($bonusValLastSaved).button('toggle');
    } else if ($bonusValLastClicked > -1) {
      $("div#bonusradio button").eq($bonusValLastClicked).removeClass('active');
    }

    $bonusValLastClicked = $bonusValLastSaved;
  }

  function onBonusValueSaveClick(event) {
    $bonusValLastSaved = $bonusValLastClicked;

    $("tr", $bonusValueTable).replaceWith($bonusValImages[$bonusValLastSaved]);
    $($formSelectors.bonusValue).val($bonusValLastSaved);

    $("div#bonusmodal").modal('hide');
  }

  function selectChangeHandler(handler) {
    if ($currentChangeHandler != handler) {
      if ($currentChangeHandler != null) {
        $currentChangeHandler();
        selectKeyboardHandler(null);
      }

      $currentChangeHandler = handler;
    }
  }

  function selectKeyboardHandler(handler) {
    if ($currentKeyHandler != handler) {
      if ($currentKeyHandler != null) {
        $(document).off('keydown', $currentKeyHandler);
      }

      $currentKeyHandler = handler;
      $(document).on('keydown', handler);
    }
  }

  function onChangeFromCrossword() {
    hideCursor();
    refreshVisualCues();
    removeEditorDecorations();

    $editorCell = null;
    saveContentRefreshStats();
  }

  function onChangeFromBonusWord() {
    $bonusWordTable.removeClass('xw-active').addClass('xw-inactive');

    var cellIdx = $bonusWordTable.data('active');
    if( cellIdx < 5 ) {
      var activeCell = $("div.xw-cell", $bonusWordTable).eq(cellIdx);
      $("img.xw-value", activeCell).attr(
        'src', $valueImages.attr(activeCell.data('content')));
    }
  }

  function onChangeFromYourLetters() {
    var cellIdx = $yourLettersTable.data('active');
    if( cellIdx < 18 ) {
      var activeCell = $("div.xw-cell", $yourLettersTable).eq(cellIdx);
      $("img.xw-value", activeCell).attr(
        'src', $valueImages.attr(activeCell.data('content')));
    }
  }

  function onCrosswordKeyInput(event) {
    if ($editorCell == null) { return true; }
    if (!event) var event = window.event;

    var keyValue = event.keyCode;
    if( keyValue == null ) { return true; }
  
    // Accept DEL, RETURN, TAB, arrows, and letters.
    if (keyValue >= 65 && keyValue <= 90) { 
      setCharacter(String.fromCharCode(keyValue));
    } else if (keyValue == 8) {
      clearCharacter();   // <BACKSPACE> unsets a character
    } else if (keyValue == 999) {
      // <SPACE> marks a tripling multiplier TODO
    } else if (keyValue == 9) {
      if ($hasAltDir) { 
        toggleDirectionMode();   // <TAB> toggles horiz/vert direction modes
        refreshVisualCues();
      }
    } else if ((keyValue == 27) || (keyValue == 13)) {
      selectChangeHandler(null);  // <RETURN> or <ESC> stops editting.
    } else if (keyValue == 37) {
      goLeft();   // <LEFT> moves the cursor left
    } else if (keyValue == 38) {
      goUp();     // <UP> moves the cursor up
    } else if (keyValue == 39) {
      goRight();  // <RIGHT> moves the cursor right
    } else if (keyValue == 40) {
      goDown();   // <DOWN> moves the cursor down
    }
  
    return false;
  }

  function onBonusWordKeyInput(event) {
    var retVal = onFocusTableKeyInput(event, $bonusWordTable);

    // Determine the cumulative word content and save when the editor is 
    // losing focus.
    // TODO: Refactor the content of this block to a shared method.
    if ( (! retVal) && ($currentChangeHandler == null) ) {
      var bonusWord = '';
      var focusCells = $("div.xw-cell", $bonusWordTable);
      for( var ii=0; ii<5; ii++ ) {
        bonusWord = bonusWord + focusCells.eq(ii).data('content');
      }

      // Set the bonus word form field value
      $($formSelectors.bonusWord).val(bonusWord);

      // Save changes 
      saveContentRefreshStats();
    }
  }

  function onYourLettersKeyInput(event) {
    var retVal = onFocusTableKeyInput(event, $yourLettersTable);

    // Determine the cumulative word content and save when the editor is 
    // accepting a new letter, yielding a new calculation of prize stats.
    // TODO: Prevent cursor movement from triggering a save.
    // TODO: Refactor the content of this block to a shared method.
    if ( (! retVal) && ($currentChangeHandler == onChangeFromYourLetters) ) {
      var revealed = '';
      var focusCells = $('div.xw-cell', $yourLettersTable);
      for( var ii=0; ii<18; ii++ ) {
        revealed = revealed + focusCells.eq(ii).data('content');
      }

      // Set the bonus word form field value
      $($formSelectors.revealed).val(revealed);

      // Save content and update prize statistics
      saveContentRefreshStats();
    }

    return retVal;
  }
  
  function onFocusTableKeyInput(event, focusTable) {
    if (!event) var event = window.event;

    var keyValue = event.keyCode;
    if( keyValue == null ) { return true; }

    var focusCells = $("div.xw-cell", focusTable);
    var cellIdx = focusTable.data('active');
    var maxCellIdx = focusCells.size();
    if(cellIdx < 0 || cellIdx > maxCellIdx) { return false; }

    // Accept DEL, RETURN, TAB, arrows, and letters.
    if (keyValue >= 65 && keyValue <= 90 && cellIdx < maxCellIdx) { 
      var activeCell = focusCells.eq(cellIdx);
      var keyChar = String.fromCharCode(keyValue);
      $("img.xw-value", activeCell).attr('src', $valueImages.attr(keyChar));
      activeCell.data('content', keyChar)

      cellIdx = cellIdx + 1;
      if (cellIdx < maxCellIdx) {
        activeCell = focusCells.eq(cellIdx);
        $("img.xw-value", activeCell).attr('src', $cursorImage);
      }
    } else if (keyValue == 27 || keyValue == 13) {
      // <ESC> and <RETURN> each stop editting and accept changes

      // Remove visual focus and keyboard handler
      selectChangeHandler(null);
    } else if (keyValue == 37 && cellIdx > 0) {
      // <LEFT> shifts the cursor left if possible.
      var activeCell;
      if (cellIdx < maxCellIdx) {
        activeCell = focusCells.eq(cellIdx);
        $("img.xw-value", activeCell).attr(
          'src', $valueImages.attr(activeCell.data('content')));
      }

      cellIdx = cellIdx - 1;
      activeCell = focusCells.eq(cellIdx);
      $("img.xw-value", activeCell).attr('src', $cursorImage);
    } else if (keyValue == 39 && cellIdx < maxCellIdx) {
      // <RIGHT> shifts the cursor right if possible.
      var activeCell = focusCells.eq(cellIdx);
      $("img.xw-value", activeCell).attr(
        'src', $valueImages.attr(activeCell.data('content')));
      
      cellIdx = cellIdx + 1;
      if (cellIdx < maxCellIdx) {
        activeCell = focusCells.eq(cellIdx);
        $("img.xw-value", activeCell).attr('src', $cursorImage);
      }
    }

    focusTable.data('active', cellIdx);
    return false;
  }
  
  function onCrosswordContext(event) {
    var wrap = $(this); 
    var row = wrap.data('rowid');
    var col = wrap.data('colid');
    var cellState = $physicalGrid[row][col];

    if (cellState.selfNode.data('triple') == 1) {
      cellState.selfNode.data('triple', 0);
    } else {
      if ($tripleCellCount >= 4) {
        // Render unselectable error.
        return false;
      } else if (isBlank(cellState)) {
        // Render illegal blank target.
        return false;
      } else if ((isFilled(cellState.toAbove) ||
                  isFilled(cellState.toBellow)) &&
                 (isFilled(cellState.toLeft) ||
                  isFilled(cellState.toRight))) {
        // Render illegal intersection.
        return false;
      }

      cellState.selfNode.data('triple', 1);
    }

    // Render add triple context option.
    refreshVisualCues();
    return true;
  }
  
  //
  // Change-of-context cleanup methods
  // 
  function goToCell(rowIdx, colIdx) {
    if ((rowIdx < 0) || (colIdx < 0) || (rowIdx > 10) || (colIdx > 10)) {
      return false;
    }

    var cellState = $physicalGrid[rowIdx][colIdx];
  
    if($editorCell != null) {
      if (! isWord(cellState)) {
        if ((isWordTail(cellState.toLeft)) &&
            (isFilled(cellState.toLeft))) {
          shiftWordTail(cellState.toLeft, cellState);
          moveCursor($editorCell, cellState);

          return true;
        } else if ((isWordHead(cellState.toRight)) &&
                   (isFilled(cellState.toRight))) {
          shiftWordHead(cellState.toRight, cellState);
          moveCursor($editorCell, cellState);

          return true;
        }
      } else {
        moveCursor($editorCell, cellState);

        return true;
      }
    }

    // If all 22 words are accounted for, disallow selections that are not
    // contiguous with an existing word.
    // TODO: Short words will still fool this test...
    if (isBlank(cellState) && ($wordCount >= 22)) {
      return showMaxWordsError();
    }

    if ((cellState.open.parallel.length < 3) &&
        (cellState.open.crossing.length < 3)) {
      return showLockedOutCellError(cellState);
    }

    // We can commit to releasing any previous editor at this point.
    if ($editorCell != null) {
      onChangeFromCrossword();
    }

    if(cellState.open.parallel.length < 3) {
      toggleDirectionMode();

      $hasAltDir  = false;
      $editorCell = $physicalGrid[rowIdx][colIdx];
    } else {
      if (cellState.open.crossing.length < 3) {
        $hasAltDir  = false;
      } else {
        $hasAltDir  = true;
      }

      $editorCell = cellState;
    }

    $openRange = $editorCell.open.parallel;
    $wordRange = bootstrapWordRange($editorCell);

    decorateEditRegion();
    showCursor();
  }

  function bootstrapWordRange(midCell) {
    var leftCell, rightCell;
    var lastLeftCell, lastRightCell;
    if (isBlank(midCell)) {
      if (isFilled(midCell.toLeft)) {
        lastLeftCell = midCell.toLeft;
      } else {
        lastLeftCell = midCell;
      }

      if (isFilled(midCell.toRight)) {
        lastRightCell = midCell.toRight;
      } else {
        lastRightCell = midCell;
      }
    } else {
      lastLeftCell = midCell;
      lastRightCell = midCell;
    }
    leftCell = lastLeftCell.toLeft;
    rightCell = lastRightCell.toRight;

    while(isFilled(leftCell)) {
      lastLeftCell = leftCell;
      leftCell = leftCell.toLeft;
    }
    leftCell = lastLeftCell;

    while(isFilled(rightCell)) {
      lastRightCell = rightCell;
      rightCell = rightCell.toRight;
    }
    rightCell = lastRightCell;

    return({
      head:   leftCell.col,
      tail:   rightCell.col,
      length: rightCell.col - leftCell.col + 1
    });
  }

  function saveContentRefreshStats() {
    var url;
    var idField;
    idField = $('input:hidden#crossword_id')
    if (idField.size() > 0) {
      url = '/crosswords/' + idField.val() + '.json';
    } else {
      url = '/crosswords.json';
    }

    console.log( url )
    console.log( $('form').serialize() )
    console.log(idField)
    jQuery.ajax({
      type: 'POST',
      url: url,
      data: $('form').serialize(),
      success: function(response) {
        console.log("Response Data Follows")
        console.log(response)
        $("debug_messages").append("<p><b>URL: {url}</p>".format({url : url}));
        $("debug_messages").append("<p><b>Query String: {data}</p>".format({data : $('form').serialize()}));
        $("debug_messages").append("<p><b>Response: {response}</p>".format({response : response}));

        response = eval(response);
        if (response.id > 0) {
          
          if (idField.size() > 0) {
            idField.val(response.id)
          } else {
            $('form').append('<input type="hidden" id="crossword_id" name="crossword_id" value="' + response.crossword_id + '"/>')
          }

          ws.send({id:response.id})
        }
      },
      error: function(response) {
        console.log("ERROR")
        console.log(response)
      }
    });
  }

  // Let 'a', 'b', and 'c' designate any three consecutive cells, with
  // valid corner cases when 'a' or 'c' is null at the graph edges, but with
  // 'b' != null as an invariant.  Iterate through all 'b' values from left to
  // right.  On each iteration, label cells immediately above, below, and on
  // a diagonal to the right as follows:
  //
  // - m n
  // a b c
  // - p q
  // 
  // The task of finding open regions amounts to finding all b such that either
  // m and n are filled or p and q are filled, or m, n, p, and q are all filled.
  // There is an open region that closes at each such b value.  The region
  // always begins at the first preceding "b" value to not close a region.  How
  // its end points are defined depends on the state of "c".
  // -- If "c" is filled, then "a" is the last cell of the preceding region,
  //    "b" must be empty and it both begins and ends a second open region of
  //    size unity, which renders it incapable of supporting a word.  Finally,
  //    "c" is the beginning of a third region whose closing end is unknown.
  // -- If "c" is empty, then "b" is the last cell of the preceding region, and
  //    "c" begins a new region (but if m/n or p/q continue to the right, that
  //    new region will get truncated to unity very quickly.
  function refreshVisualCues() {
    $wordCount = 0;
    $('span.badge', $wordBadgeTable).text('');
    $('div.xw-cell', $crosswordTable).removeClass('xw-short xw-triple xw-tripshort xw-dualtrip xw-dualtripshort xw-blocked');

    var rowTrack = [ ];
    var colTrack = [ ];
    for( var ii=0; ii<11; ii++ ) {
      rowTrack[ii] = { openStart: null, wordRun: $(), isHorizontal: true };
      colTrack[ii] = { openStart: null, wordRun: $(), isHorizontal: false };
    }

    var blockedFlags = { rowBlocked: $(), colBlocked: $() };
    var wordModFlags = 
      { shortHRuns: $(), shortVRuns: $(), hTriples: $(), vTriples: $() };

    // Check down the row.  If a cell is populated, it must be in an unlocked
    // space by definition.  If a cell is blank, check its corner adjacencies,
    // and if none are full, it is unlocked.
    //
    // When a locked cell is found, openStart has the index of the first 
    // preceding unlocked cell.  Set every cell between it and the present with
    // the open region bounds discovered, then increment openStart and keep 
    // on searching.
    for( var ii=0; ii<11; ii++ ) {
      for( var jj=0; jj<11; jj++ ) {
        var thisCell = $horizontalGrid[ii][jj];

        // Do both horizontal and vertical word tracking first.
        if (! isFilled(thisCell)) {
          markWordBoundary(rowTrack[ii], wordModFlags);
          markWordBoundary(colTrack[jj], wordModFlags);
        } else {
          rowTrack[ii].wordRun = rowTrack[ii].wordRun.add(thisCell.selfNode);
          colTrack[jj].wordRun = colTrack[jj].wordRun.add(thisCell.selfNode);
        }

        // Next, check horizontal open region boundaries.
        if ((isFilled(thisCell.toAbove) &&
             isFilled(thisCell.toAbove.toRight)) ||
            (isFilled(thisCell.toBelow) &&
             isFilled(thisCell.toBelow.toRight))) {
          if(isFilled(thisCell.toRight)) {
            scanInRow(rowTrack[ii].openStart, thisCell.toLeft, blockedFlags);
            scanInRow(thisCell, thisCell, blockedFlags);
          } else {
            scanInRow(rowTrack[ii].openStart, thisCell, blockedFlags);
          }

          rowTrack[ii].openStart = thisCell.toRight;
        }

        // Next, check horizontal open region boundaries.
        if ((isFilled(thisCell.toLeft) &&
             isFilled(thisCell.toLeft.toBelow)) ||
            (isFilled(thisCell.toRight) &&
             isFilled(thisCell.toRight.toBelow))) {
          if(isFilled(thisCell.toBelow)) {
            scanInCol(colTrack[jj].openStart, thisCell.toAbove, blockedFlags);
            scanInCol(thisCell, thisCell, blockedFlags);
          } else {
            scanInCol(colTrack[jj].openStart, thisCell, blockedFlags);
          }

          colTrack[jj].openStart = thisCell.toBelow;
        }
      }
        
      // Close off the remaining horizontal words and open horizontal region
      // boundary discoveries at end-of-row.
      markWordBoundary(rowTrack[ii], wordModFlags);
      scanInRow(rowTrack[ii].openStart, thisCell, blockedFlags);
    }
  
    // Close off the remaining vertical words and open vertical region boundary
    // discoveries at end-of-grid.
    for( var jj=0; jj<11; jj++ ) {
      markWordBoundary(colTrack[jj], wordModFlags);
      scanInCol(colTrack[jj].openStart, $horizontalGrid[10][jj], blockedFlags);
    }

    // Mark three subsets of filled cell modifiers:
    // -- Short (not part of a 3 letter run in either direction)
    // -- Triple (bears a prize tripling modifier)
    // -- Short Triple (not part of a 3 letter run and bears a tripling mod)
    // -- Dual Triple (prize tripling modifier at a word intersection)
    // -- Short Dual Triple (prize tripling modifier at an intersection of 
    //                       a pair of two-letter runs).
    var shortRuns = wordModFlags.shortHRuns.filter(wordModFlags.shortVRuns);
    var allTrips  = wordModFlags.hTriples.add(wordModFlags.vTriples);
    var dualTrips = wordModFlags.hTriples.filter(wordModFlags.vTriples);
    var monoTrips = allTrips.not(dualTrips);

    $tripleCellCount = $tripleCellCount - dualTrips.size;

    shortRuns.filter(monoTrips).addClass('xw-tripshort');
    shortRuns.filter(dualTrips).addClass('xw-dualtripshort');
    shortRuns.not(allTrips).addClass('xw-short');
    monoTrips.not(shortRuns).addClass('xw-triple');
    dualTrips.not(shortRuns).addClass('xw-dualtrip');

    // Mark cells that are blocked in both directions for the regular UI and
    // those blocked in only one direction for the debugging style sheet.
    var allBlocked = blockedFlags.rowBlocked.filter(blockedFlags.colBlocked);
    allBlocked.addClass('xw-blocked');
  }

  function scanInRow(headCell, tailCell, blockedFlags) {
    var regionCell, rangeLen, finalIdx;
    var blockedCells = blockedFlags.rowBlocked;

    if(headCell == null) {
      if(tailCell == null) { return; }

      rangeLen = tailCell.col + 1;
      finalIdx = tailCell.col;
      regionCell = tailCell;
      while(regionCell != headCell) {
        regionCell.open.parallel.head = 0;
        regionCell.open.parallel.tail = finalIdx;
        regionCell.open.parallel.length = rangeLen;

        if (rangeLen < 3) {
          blockedCells = blockedCells.add(regionCell.selfNode);
        }

        regionCell = regionCell.toLeft;
      }
    } else {
      if(tailCell == null) {
        rangeLen = 11 - headCell.col;
        finalIdx = 10;
      } else if(headCell.col >= tailCell.col) {
        tailCell.open.parallel.head = tailCell.col;
        tailCell.open.parallel.tail = tailCell.col;
        tailCell.open.parallel.length = 1;
 
        blockedFlags.rowBlocked = blockedCells.add(tailCell.selfNode);
        return;
      } else {
        rangeLen = tailCell.col - headCell.col + 1;
        finalIdx = tailCell.col;
      }

      regionCell = headCell;
      while(regionCell != tailCell) {
        regionCell.open.parallel.head = headCell.col;
        regionCell.open.parallel.tail = finalIdx;
        regionCell.open.parallel.length = rangeLen;

        if( rangeLen < 3 ) { 
          blockedCells = blockedCells.add(regionCell.selfNode);
        }

        regionCell = regionCell.toRight;
      }
    }

    blockedFlags.rowBlocked = blockedCells;
    return closed;
  }

  function scanInCol(headCell, tailCell, blockedFlags) {
    var regionCell, rangeLen, finalIdx;
    var blockedCells = blockedFlags.colBlocked;

    if (headCell == null) {
      if (tailCell == null) { return closed; }

      rangeLen = tailCell.row + 1;
      finalIdx = tailCell.row;
      regionCell = tailCell;
      while(regionCell != headCell) {
        regionCell.open.crossing.head = 0;
        regionCell.open.crossing.tail = finalIdx;
        regionCell.open.crossing.length = rangeLen;

        if (rangeLen < 3) { 
          blockedCells = blockedCells.add(regionCell.selfNode);
        }

        regionCell = regionCell.toAbove;
      }
    } else {
      if (tailCell == null) {
        rangeLen = 11 - headCell.row;
        finalIdx = 10;
      } else if (headCell.row >= tailCell.row) {
        tailCell.open.crossing.head = tailCell.row;
        tailCell.open.crossing.tail = tailCell.row;
        tailCell.open.crossing.length = 1;

        blockedFlags.colBlocked = blockedCells.add(tailCell.selfNode);
        return;
      } else {
        rangeLen = tailCell.row - headCell.row + 1;
        finalIdx = tailCell.row;
      }

      regionCell = headCell;
      while(regionCell != tailCell) {
        regionCell.open.crossing.head = headCell.row;
        regionCell.open.crossing.tail = finalIdx;
        regionCell.open.crossing.length = rangeLen;

        if (rangeLen < 3) { 
          blockedCells = blockedCells.add(regionCell.selfNode);
        }

        regionCell = regionCell.toBelow;
      }
    }

    blockedFlags.colBlocked = blockedCells;
    return closed;
  }

  function markWordBoundary(trackObj, wordModFlags) {
    var wordRun = trackObj.wordRun;
    var isHorizontal = trackObj.isHorizontal;

    if (wordRun.size() > 0) {
      if (wordRun.size() < 3) {
        if (isHorizontal) {
          wordModFlags.shortHRuns = wordModFlags.shortHRuns.add(wordRun);
        } else {
          wordModFlags.shortVRuns = wordModFlags.shortVRuns.add(wordRun);
        }

        wordRun.each(
          function(letterIdx, cell) { 
            var wrappedCell = $(cell);
            if (wrappedCell.data('triple') == 1) {
              if (isHorizontal) {
                wordModFlags.hTriples = wordModFlags.hTriples.add(wrappedCell)
              } else {
                wordModFlags.vTriples = wordModFlags.vTriples.add(wrappedCell)
              }

              $tripleCellCount = $tripleCellCount + 1;
            }
          }
        );
      } else {
        var firstCell = trackObj.wordRun.first()
        var subst = { idx: $wordCount };
        var text_value = '';

        wordRun.each(
          function(letterIdx, cell) { 
            var wrappedCell = $(cell);
  
            text_value = text_value + wrappedCell.data('content');
  
            if (wrappedCell.data('triple') == 1) {
              $($formSelectors.tripleIndex.format(subst)).val(letterIdx);

              if (isHorizontal) {
                wordModFlags.hTriples = wordModFlags.hTriples.add(wrappedCell)
              } else {
                wordModFlags.vTriples = wordModFlags.vTriples.add(wrappedCell)
              }

              $tripleCellCount = $tripleCellCount + 1;
            }
          }
        );
        
        // Update form fields.
        $($formSelectors.textValue.format(subst)).val(text_value);
        $($formSelectors.xCoord.format(subst)).val(firstCell.data('rowid'));
        $($formSelectors.yCoord.format(subst)).val(firstCell.data('colid'));
        $($formSelectors.isHoriz.format(subst)).val(isHorizontal);

        // Display badges self-collapse when empty and self-reveal when
        // given content.  Awesome!
        $('span.badge', $wordBadgeTable).eq($wordCount).text(text_value);

        $wordCount = $wordCount + 1;
      }

      // Empty out the accumulated word run since whitespace closed it.
      trackObj.wordRun = $()
    }
  }

  //
  // Orientation-aware cell decoration.  Not a public interface
  //

  var $horizontalStrategy = {
    toggleDirectionMode: function() {
      $dirModeStrategy = $verticalStrategy;
      $physicalGrid = $verticalPhysical;
      $logicalGrid = $verticalLogical;
      
      $crosswordTable.removeClass('xw-horizontal').addClass('xw-vertical');

      if($editorCell != null) {
        $editorCell = $logicalGrid[$editorCell.col][$editorCell.row];
      }
    },

    goLeft: function() { goToCell( $editorCell.row, $editorCell.col - 1 ); },
    goUp: function() { goToCell( $editorCell.row - 1, $editorCell.col ); },
    goRight: function() { goToCell( $editorCell.row, $editorCell.col + 1 ); },
    goDown: function() { goToCell( $editorCell.row + 1, $editorCell.col ); },

    decorateEditRegion: function(open, word) {
      open.addClass('xw-open xw-asrow');
      word.addClass('xw-word');
    },
  };

  var $verticalStrategy = {
    toggleDirectionMode: function() {
      $dirModeStrategy = $horizontalStrategy;
      $physicalGrid = $horizontalGrid;
      $logicalGrid = $horizontalGrid;

      $crosswordTable.removeClass('xw-vertical').addClass('xw-horizontal');
      
      if ($editorCell != null) {
        $editorCell = $logicalGrid[$editorCell.col][$editorCell.row];
      }
    },

    goLeft: function() { goToCell( $editorCell.col, $editorCell.row - 1 ); },
    goUp: function() { goToCell( $editorCell.col - 1, $editorCell.row ); },
    goRight: function() { goToCell( $editorCell.col, $editorCell.row + 1 ); },
    goDown: function() { goToCell( $editorCell.col + 1, $editorCell.row ); },

    decorateEditRegion: function(open, word) {
      open.addClass('xw-open xw-ascol');
      word.addClass('xw-word');
    }
  };

  var $dirModeStrategy = $horizontalStrategy

  function toggleDirectionMode() {
    $dirModeStrategy.toggleDirectionMode();

    if ($editorCell != null) {
      $openRange = $editorCell.open.parallel;
      $wordRange = bootstrapWordRange($editorCell);

      removeEditorDecorations();
      decorateEditRegion();
    }
  }

  function goLeft() { $dirModeStrategy.goLeft(); }
  function goUp() { $dirModeStrategy.goUp(); }
  function goRight() { $dirModeStrategy.goRight(); }
  function goDown() { $dirModeStrategy.goDown(); }

  function removeEditorDecorations() {
    $('div.xw-cell', $crosswordTable).removeClass(
      'xw-open xw-word xw-wordhead xw-wordtail xw-midword xw-asrow xw-ascol');
  }

  function decorateEditRegion() {
    var cells = $editorCell.sameRow;
    var word  = cells.slice($wordRange.head, $wordRange.tail + 1);

    // Indicate the border positions which will combine with the orientation
    // class set in the delegate method below.
    word.first().addClass("xw-wordhead");
    word.slice(1, $wordRange.length - 1).addClass("xw-midword");
    word.last().addClass("xw-wordtail");

    // Fill in the details about "row-ness" or "column-ness" by delegation.
    var open = cells.slice($openRange.head, $openRange.tail + 1);
    $dirModeStrategy.decorateEditRegion(open, word);
  }
      
  function shiftWordHead(fromCell, toCell) {
    if(toCell.col > $wordRange.tail) { 
      alert('Coding error!  Illegal move of word head to <' + toCell.col + '> after word at <{head},{tail}>!'.format($wordRange));
    } else if((toCell.col < $openRange.head) ||
              (toCell.col > $openRange.tail)) {
      alert('Coding error!  Illegal move of word head to <' + toCell.col + '> beyond open range of <{head},{tail}>!'.format($openRange));
    }

    if(fromCell.col < toCell.col) {
      // Head is moving right.  Prune word markers from all cells until the new
      // destination is reached.  Remove a mid-word tag from the new destination
      // cell, and apply the head tag.  If that cell happens to be the tail,
      // then removing the mid tag will be a harmless no-op.  Its not worth 
      // exerting to test for tail-ness.
      var nextCell = fromCell;
      while(nextCell != toCell) {
        nextCell.selfNode.removeClass('xw-wordhead xw-word xw-midword');
        nextCell = nextCell.toRight;
      }

      toCell.selfNode.removeClass('xw-midword').addClass('xw-wordhead');
    } else {
      // Head is moving left.  Prune old head marker from head and then add a
      // mid marker to every cell leading up to the new head location.  If the
      // old head is also currently the tail, make one exception and do not
      // apply the mid label there--it will retain its "tail" class.
      var nextCell = fromCell;
      nextCell.selfNode.removeClass('xw-wordhead');
      if(isWordTail(nextCell)) { nextCell = nextCell.toLeft; }
      while(nextCell != toCell) {
        nextCell.selfNode.addClass('xw-word xw-midword');
        nextCell = nextCell.toLeft;
      }

      toCell.selfNode.addClass('xw-word xw-wordhead');
    }

    $wordRange.head = toCell.col;
    $wordRange.length = 1 + $wordRange.tail - $wordRange.head;
  }

  function shiftWordTail(fromCell, toCell) {
    if(toCell.col < $wordRange.head) { 
      alert('Coding error!  Illegal move of word tail to <' + toCell.col + '> before word at <{head},{tail}>!'.format($wordRange));
    } else if((toCell.col < $openRange.head) ||
              (toCell.col > $openRange.tail)) {
      alert('Coding errror!  Illegal move of word tail to <' + toCell.col + '> beyond open range of <{head},{tail}>!'.format($openRange));
    }

    if(fromCell.col > toCell.col) {
      // Head is moving right.  Prune word markers from all cells until the new
      // destination is reached.  Remove a mid-word tag from the new destination
      // cell, and apply the head tag.  If that cell happens to be the tail,
      // then removing the mid tag will be a harmless no-op.  Its not worth 
      // exerting to test for tail-ness.
      var nextCell = fromCell;
      while(nextCell != toCell) {
        nextCell.selfNode.removeClass('xw-wordtail xw-word xw-midword');
        nextCell = nextCell.toLeft;
      }

      toCell.selfNode.removeClass('xw-midword').addClass('xw-wordtail');
    } else {
      // Head is moving left.  Prune old head marker from head and then add a
      // mid marker to every cell leading up to the new head location.  If the
      // old head is also currently the tail, make one exception and do not
      // apply the mid label there--it will retain its "tail" class.
      var nextCell = fromCell;
      fromCell.selfNode.removeClass('xw-wordtail');
      if(isWordHead(nextCell)) { nextCell = fromCell.toRight; }
      while(nextCell != toCell) {
        nextCell.selfNode.addClass('xw-word xw-midword');
        nextCell = nextCell.toRight;
      }

      toCell.selfNode.addClass('xw-word xw-wordtail');
    }

    $wordRange.tail = toCell.col;
    $wordRange.length = 1 + $wordRange.tail - $wordRange.head;
  }

  function moveCursor(fromCell, toCell) {
    var cursorReplacement
    if (isBlank(fromCell)) {
      cursorReplacement = $blankImage
    } else {
      cursorReplacement =
        $valueImages.attr($editorCell.selfNode.data('content'));
    }

    $hasAltDir  = toCell.open.crossing.length >= 3;

    $('img.xw-value', fromCell.selfNode).attr('src', cursorReplacement);
    $('img.xw-value', toCell.selfNode).attr('src', $cursorImage);

    $editorCell = toCell;
  }

  //
  // Content If Not Null Helpers
  //

  // isBlank() and isFilled() each return false on null input.  Depending on
  // how null is expected to be handled, it may be favorible to negate the
  // result of the check opposite what is desired.
  //
  // e.g. (cell != null && isBlank(cell)) can be written more succintly as
  //      (! isFilled(cell)) without loss of correct null handling, whereas
  //      (isBlank(cell)) would cause bugs on null input.
  //
  // +=======+===========+============+
  // | INPUT | isBlank() | isFilled() |
  // +=======+===========+============+
  // | null  |   FALSE   |    FALSE   |
  // |  'c'  |   FALSE   |    TRUE    |
  // |  ''   |   TRUE    |    FALSE   |
  // +=======+===========+============+
  function isBlank(cell) {
    return ((cell != null) && (cell.selfNode.data('content') == ''));
  }

  function isFilled(cell) {
    return ((cell != null) && (cell.selfNode.data('content') != ''));
  }

  function isOpen(cell) {
    return ((cell != null) &&
            (cell.row == $editorCell.row) &&
            (cell.col >= $openRange.head) &&
            (cell.col <= $openRange.tail));
  }

  function isWord(cell) {
    return ((cell != null) &&
            (cell.row == $editorCell.row) &&
            (cell.col >= $wordRange.head) &&
            (cell.col <= $wordRange.tail));
  }

  function isWordHead(cell) {
    return ((cell != null) &&
            (cell.row == $editorCell.row) &&
            (cell.col == $wordRange.head));
  }

  function isWordTail(cell) {
    return ((cell != null) &&
            (cell.row == $editorCell.row) &&
            (cell.col == $wordRange.tail));
  }

  function getWordHead() {
    return $logicalGrid[$editorCell.row][$wordRange.head];
  }

  function getWordTail() {
    return $logicalGrid[$editorCell.row][$wordRange.tail];
  }

  //
  // Cursor management interface
  //

  function showCursor() {
    $('img.xw-value', $editorCell.selfNode).attr('src', $cursorImage);
  }

  function hideCursor() {
    var cursorReplacement;

    if (isBlank($editorCell)) {
      cursorReplacement = $blankImage
    } else {
      cursorReplacement =
        $valueImages.attr($editorCell.selfNode.data('content'));
    }

    $('img.xw-value', $editorCell.selfNode).attr('src', cursorReplacement);
  }

  function setCharacter(c) {
    $editorCell.selfNode.data('content', c);

    var rightCell = $editorCell.toRight;
    if (! isOpen(rightCell)) { return; }

    moveCursor($editorCell, rightCell);
    if (! isWord(rightCell)) {
      while(isFilled(rightCell.toRight)) { rightCell = rightCell.toRight; }
      shiftWordTail($editorCell.toLeft, rightCell);
    }
  }

  function clearCharacter() {
    // Backspace removes a character left of the current cell and therefore
    // does not apply to the top cell of a word.
    if (isWordHead($editorCell)) { return false; }
  
    // If the current cell is blank, leave cells to the right alone, and 
    // let the editor cell be the last cell to shift left.  Otherwise, let the
    // last cell of the present word be the last cell to shift left.
    var pruneCell;
    if (isBlank($editorCell)) {
      pruneCell = $editorCell;
    } else {
      pruneCell = getWordTail();
    }

    // Shift all content from $editorCell to pruneCell left by one cell, then
    // blank out the content of pruneCell.
    var thisCell  = $editorCell.toLeft;
    var thisImg   = $('img.xw-value', thisCell.selfNode);
    var nextCell  = $editorCell;
    var nextImg   = null;
    while (thisCell != pruneCell) {
      thisCell.selfNode.data('content', nextCell.selfNode.data('content'));
  
      nextImg  = $('img.xw-value', nextCell.selfNode);
      thisImg.attr('src', nextImg.attr('src'));
      
      thisCell = nextCell;
      thisImg  = nextImg;
      nextCell = thisCell.toRight;
    }
    thisCell.selfNode.data('content', '');
    thisImg.attr('src', $blankImage);
  
    // Reduce the active word region to one left of pruneCell, then shift the
    // cursor one cell to the left from $editorCell.
    shiftWordTail(pruneCell, pruneCell.toLeft);
    moveCursor($editorCell, $editorCell.toLeft);
  }

  //
  // Error Modal Displays
  //

  function showMaxWordsError() { alert('Max Words'); return false; }

  function showLockedOutCellError() { alert('That cell is locked out'); return false; }

